<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook">

<info>
    <title>GRAL Documentation</title>
    <author><firstname>Erich</firstname><surname>Seifert</surname></author>
    <author><firstname>Michael</firstname><surname>Seifert</surname></author>
    <copyright><year>2011</year><holder>Erich Seifert</holder><holder>Michael Seifert</holder></copyright>
</info>

<chapter xml:id="data">
    <title>Data administration</title>

    <para>The first step, before we are able to plot anything, is to load or
    create data, a process which GRAL provides several ways for. The basic
    interface that will be used when you have to provide data is
    <interfacename>DataSource</interfacename>. Think of it as a table with a
    (theoretically) arbitrary number of rows and columns. Every column has its
    own data type, but only<classname>Number</classname> values are allowed.
    The functions a <interfacename>DataSource</interfacename> provides are
    solely for retrieving data rows, but it also supports statistics on the
    contained data, as well as the capability to listen for data changes. The
    following sections describe the different ways for providing and
    manipulating data.</para>

    <sect1 xml:id="data.create">
        <title>Creating data</title>

        <para>Assuming you have computed some values you want to plot, how can
        you store your data in a <interfacename>DataSource</interfacename>? You
        can do so through the class <classname>DataTable</classname>.
        <classname>DataTable</classname> is an implementation of
        <interfacename>DataSource</interfacename> (or
        <classname>AbstractDataSource</classname> to be more precise) and
        supports operations like adding and removing rows.
        The values you must match the number of columns and their types, which
        both had already been specified in the constructor.</para>

        <example xml:id="example.data.create.add">
            <title>Populating a <classname>DataTable</classname></title>
            <programlisting language="java"><![CDATA[
// Create the table with the specified column types
DataTable table = new DataTable(Double.class, Double.class);

// Iterate your available data. In this case, an Iterable<Double[]> or Double[][]
for (Double[] coords : data) {
    double x = coords[0];
    double y = coords[1];
    table.add(x, y);
}
]]></programlisting>
        </example>

        <para>You might want to have a <classname>DataTable</classname> for
        testing purposes only and do not want to create random values for it at
        each start. In this case, the class <classname>DummyData</classname> is
        your remedy. <classname>DummyData</classname> is a
        <interfacename>DataSource</interfacename> filled with a single value.
        As I already mentioned, this is not used very often, but suited very
        well for testing due to its efficiency, especially when dealing with
        large tables.</para>

        <example xml:id="example.data.create.dummy">
            <title>Generating dummy data</title>
            <programlisting language="java"><![CDATA[
DummyData data = new DummyData(3, 100, 42.0);
]]></programlisting>
        </example>
    </sect1>

    <sect1 xml:id="data.sort">
        <title>Sorting data</title>

        <para>Often, data has to be reordered, e.g. for filtering. The sorting
        criteria in GRAL can be handled very flexible: for example the rows of
        a data source could be rearranged so that the first column is sorted
        ascending and as a second criterion the second column is sorted
        descending when values of the first column are equal. GRAL uses two
        classes to define the sorting options: <classname>Ascending</classname>
        and <classname>Descending</classname>. In order to create one of them
        you must pass the index of the column that should be sorted to the
        constructor.</para>

        <example xml:id="example.data.sort">
            <title>Sorting</title>
            <programlisting language="java"><![CDATA[
// Sort the primary column (1) ascending,
// the secondary column (0) descending, and
// the ternary column (2) ascending
table.sort(new Ascending(1), new Descending(0), new Ascending(2));
]]></programlisting>
        </example>
    </sect1>

    <sect1 xml:id="data.filter">
        <title>Filtering data</title>

        <para><classname>DataTable</classname>s are not the only data
        source for plots. A plot also accepts filtered data. In GRAL data can
        be filtered either by columns or by rows.</para>

        <sect2 xml:id="data.filter.series">
            <title>Filtering columns</title>

            <para>The main tasks for filtering by columns are to create subsets
            (series) of columns and to reorder columns for certain plot types.
            Using the class <classname>DataSeries</classname> a data source with
            four columns (A, B, C, D) could be divided into two series: one
            containing columns (A, B) and one containing columns (C, D). The
            series could also overlap, for example the first series could
            contain the columns (A, B) and the second the columns (B, C).
            Furthermore, data series can be used to reorder columns. It is
            possible to map columns (A, B, C, D) to (D, B, C, A) or just (D, C)
            </para>

            <para>A <classname>DataSeries</classname> is created using at least
            two parameters: the original data source and a number of columns,
            which will appear in the order they are passed. Optionally a name
            can be passed as first argument. In <classname>Plot</classname>s
            this name is used for example to display captions in the plot
            legend.</para>

            <example xml:id="example.data.filter.series">
                <title>Creating a data series</title>
                <programlisting language="java"><![CDATA[
// Create a new series from columns 0 and 1
DataSeries series1 = new DataSeries("Series 1", table, 0, 1);
// Create a new series from columns 2 and 0
DataSeries series2 = new DataSeries("Series 2", table, 2, 0);
// Create a new series from column 1
DataSeries series3 = new DataSeries("Series 3", table, 1);
]]></programlisting>
            </example>
        </sect2>

        <sect2 xml:id="data.filter.subset">
            <title>Filtering rows</title>

            <para>Another way of filtering is to filter data sources by rows.
            This way a data subset which matches certain criteria can be
            extracted. For example, this could be used to form clusters
            which could then be plotted or processed separately.</para>

            <para>In order to use the <classname>DataSubset</classname> a new
            class has to be created which implements the method
            <methodsynopsis language="java"><methodname>accept</methodname><methodparam><type>Row</type><parameter>row</parameter></methodparam></methodsynopsis>.
            This method is used to decide whether a certain
            row should be kept in the subset.</para>

            <example xml:id="example.data.filter.subset">
                <title>Filtering rows with <classname>RowSubset</classname></title>
                <programlisting language="java"><![CDATA[
// Keep only rows where the first column has an even value
RowSubset data = new RowSubset(table) {
    @Override
    public boolean accept(Row row) {
        return (row.get(0).doubleValue() % 2.0) == 0.0;
    }
};
]]></programlisting>
            </example>
        </sect2>
    </sect1>

    <sect1 xml:id="data.processing">
        <title>Processing data</title>

        <para>An integral part of GRAL's pipeline is preprocessing of data.
        The simplest case would be to extract several statistics per column
        such as minimum, maximum, arithmetic mean, or median. But GRAL also
        covers more complex cases such as generating histograms or convolution
        filtering of data. The latter can be used to smooth or sharpen data
        in various ways.</para>

        <sect2 xml:id="data.processing.stats">
            <title>Statistics</title>
            <para>The most basic statistical functionality of GRAL is to query
            various aggregated measures for columns using the class
            <classname>Statistics</classname>. It is part of every
            <interfacename>DataSource</interfacename> instance and can be easily
            accessed with the method
            <methodsynopsis language="java"><methodname>getStatistics</methodname><methodparam><type>int</type><parameter>column</parameter></methodparam></methodsynopsis>.
            </para>

            <example xml:id="example.data.processing.stats.max">
                <title>Getting the maximum of a column</title>
                <programlisting language="java"><![CDATA[
// Get the maximum for the second column
double max = table.getColumn(1).getStatistics(Statistics.MAX);
]]></programlisting>
            </example>

            <variablelist>
                <title>Statistical measures provided by
                    <classname>Statistics</classname></title>
                <varlistentry>
                    <term><constant>N</constant></term>
                    <listitem><para>The number of values in the column.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>SUM</constant></term>
                    <listitem><para>The sum of all column values.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>MIN</constant></term>
                    <listitem><para>The smallest value of the column.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>MAX</constant></term>
                    <listitem><para>The largest value of the column.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>MEAN</constant></term>
                    <listitem><para>The arithmetic mean describing the average
                        value of the column.</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>MEAN_DEVIATION</constant></term>
                    <listitem><para>The mean deviation describing the
                        dispersion of the column's values.</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>MEDIAN</constant></term>
                    <listitem><para>The median value which divides the column
                        values in two equal halves.</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>VARIANCE</constant></term>
                    <listitem><para>The variance value describing the
                        dispersion of the column's values.</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>SKEWNESS</constant></term>
                    <listitem><para>The skewness value describing the asymmetry
                        of the probability distribution of the column's values.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>KURTOSIS</constant></term>
                    <listitem><para>The kurtosis value describing the
                        "peakedness" of the probability distribution of the
                        column's values.</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>QUARTILE_1</constant></term>
                    <listitem><para>The value that delimits the lower 25% of
                    all data values.</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>QUARTILE_2</constant></term>
                    <listitem><para>The value that delimits 50% of
                    all data values. This is the same as the median value.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>QUARTILE_3</constant></term>
                    <listitem><para>The value that delimits the upper 25% of
                    all data values.</para></listitem>
                </varlistentry>
            </variablelist>

            <para>Histograms are a more complex way for aggregating data. In a
            histogram all values are assigned to specified categories. In
            GRAL's <classname>Histogram</classname> class categories are
            defined as value ranges. For example all values from 0 to 5 would
            be in category A and all values from 5 to 10 in category B.
            Then, the histogram would generate two rows for each column that
            contain the number of values in category A and B, respectively.
            </para>

            <example xml:id="example.data.processing.histogram.equal">
                <title>Generating an equally spaced histogram</title>
                <programlisting language="java"><![CDATA[
// Use 4 equally spaced breaks
Histogram histogram = new Histogram1D(table, Orientation.VERTICAL, 4);
]]></programlisting>
            </example>

            <example xml:id="example.data.processing.histogram.custom">
                <title>Generating a histogram with user-defined breaks</title>
                <programlisting language="java"><![CDATA[
// Use custom breaks for each column
Number[] breaksCol1 = {1.0, 2.0, 3.0, 4.0, 5.0};
Number[] breaksCol2 = {1.0, 3.0, 5.0, 7.0, 9.0};
Histogram histogram = new Histogram1D(table, Orientation.VERTICAL,
    breaksCol1, breaksCol2);
]]></programlisting>
            </example>
        </sect2>

        <sect2 xml:id="data.processing.convolution">
            <title>Convolution</title>

            <para>Often, it is necessary to change existing data by smoothing
            it, so that noise or fine-scale structures are reduced. Another
            frequent use case is to boost or extract exactly those fine-scale
            structures.
            Both cases can be handled in GRAL using the convolution operation.
            Mathematically, convolution is the combination of two functions:
            the data function and a kernel function. By varying th kernel
            function various operations can be achieved: smoothing (low-pass
            filter), deriving (high-pass filter), sharpening, moving average,
            and much more.</para>

            <para>Besides the class <interfacename>DataSource</interfacename>
            GRAL provides two additional classes for convolution: the class
            <classname>Kernel</classname> defines the kernel function and the
            class <classname>Convolution</classname> is responsible for
            processing the data source. The <classname>Convolution</classname>
            instance can finally be used as a data source for plots.</para>

            <example xml:id="example.data.processing.convolution.moving_avg">
                <title>Creating a moving average filter</title>
                <programlisting language="java"><![CDATA[
// Create a moving average of width 3
Kernel kernel = new Kernel(1.0, 1.0, 1.0).normalize();
// Filter columns 0 and 1 and omit boundary values if necessary
Convolution filter = new Convolution(table, kernel, Filter.Mode.OMIT, 0, 1);
]]></programlisting>
            </example>

            <example xml:id="example.data.processing.convolution.smooth">
                <title>Creating a smoothing filter</title>
                <programlisting language="java"><![CDATA[
// Create a smoothing kernel with a variance of 2
Kernel kernel = KernelUtils.getBinomial(2.0).normalize();
// Filter column 1 and start over for boundary values if necessary
Convolution filter = new Convolution(table, kernel, Filter.Mode.CIRCULAR, 1);
]]></programlisting>
            </example>

            <example xml:id="example.data.processing.convolution.derive">
                <title>Creating a deriving filter</title>
                <programlisting language="java"><![CDATA[
// Create a smoothing kernel with a variance of 3
Kernel kernel = KernelUtils.getBinomial(3.0).normalize()
// Subtract the original values
kernel = kernel.negate().add(new Kernel(1.0));
// Filter column 1 and repeat boundary values if necessary
Convolution filter = new Convolution(table, kernel, Filter.Mode.REPEAT, 1);
]]></programlisting>
            </example>
        </sect2>
    </sect1>

    <sect1 xml:id="data.exchange">
        <title>Exchanging data</title>

        <para>GRAL allows you to interchange data values through its extensible
        plug-in system. Arbitrary sources and sinks can be accessed, like plain
        files, databases, or even web services. The current version of GRAL
        already supports file formats like simple <acronym>CSV</acronym> files
        (<emphasis>Comma-Separated Values</emphasis>).</para>

        <sect2 xml:id="data.exchange.import">
            <title>Importing</title>

            <para>Loading data from a source in GRAL needs two steps: First,
            you have to get a <interfacename>DataReader</interfacename> the
            desired file format via its <acronym>MIME</acronym> type from an
            instance of <classname>DataReaderFactory</classname>. Then, you
            have to call the method
            <methodsynopsis language="java"><methodname>read</methodname></methodsynopsis>
            of the reader with two (or more) parameters: an
            <classname>InputStream</classname> instance to read from and the
            column data types. The method finally reads the data and returns a
            new <interfacename>DataSource</interfacename> containing all values
            that have been extracted from the source.</para>

            <example xml:id="example.data.exchange.import">
                <title>Importing a <acronym>CSV</acronym> file</title>
                <programlisting language="java"><![CDATA[
DataReader reader = DataReaderFactory.getInstance().get("text/csv");
InputStream file = new FileInputStream("foobar.csv");
DataSource data = reader.read(file, Integer.class, Double.class, Double.class);
]]></programlisting>
            </example>

           <example xml:id="example.data.exchange.import">
                <title>Importing the values of a grayscale image</title>
                <programlisting language="java"><![CDATA[
DataReader reader = DataReaderFactory.getInstance().get("image/png");
reader.setSetting("factor", 1.0/255.0);
reader.setSetting("offset", 1);
InputStream file = new FileInputStream("foobar.png");
DataSource data = reader.read(file);
]]></programlisting>
            </example>
        </sect2>

        <sect2 xml:id="data.exchange.export">
            <title>Exporting</title>

            <para>Saving data in GRAL is even easier than loading. First, you
            need to get an instance of <classname>DataWriterFactory</classname>
            and then you fetch a <interfacename>DataWriter</interfacename> for
            the desired file format via its <acronym>MIME</acronym> type. Then,
            you have to call the method
            <methodsynopsis language="java"> <methodname>write</methodname></methodsynopsis>
            with two parameters: a <interfacename>DataSource</interfacename>
            and an <classname>OutputStream</classname> instance to write to.
            </para>

            <example xml:id="example.data.exchange.export">
                <title>Exporting a <acronym>CSV</acronym> file</title>
                <programlisting language="java"><![CDATA[
DataWriter writer = DataWriterFactory.getInstance().get("text/csv");
FileOutputStream file = new FileOutputStream("foobar.csv");
writer.write(table, file);
]]></programlisting>
            </example>

            <example xml:id="example.data.exchange.export">
                <title>Exporting a <acronym>PNG</acronym> image</title>
                <programlisting language="java"><![CDATA[
DataWriter writer = DataWriterFactory.getInstance().get("image/png");
writer.setSetting("factor",  255);
writer.setSetting("offset", -255);
FileOutputStream file = new FileOutputStream("foobar.png");
writer.write(table, file);
]]></programlisting>
            </example>
        </sect2>
    </sect1>
</chapter>

<chapter xml:id="plotting">
    <title>Displaying data</title>

    <para>The main purpose of GRAL is to plot diagrams. It offers several types
    of plots which can be customized and exported for publishing. In this chapter
    you will find an overview of plot types and their options for customization
    as well as examples how to export the plotted graphics in various formats.
    </para>

    <para>The components of a plot in GRAL are:

        <itemizedlist>
            <listitem>
                <para>Each plot has one or more instances of
                <interfacename>DataSource</interfacename></para>
            </listitem>
            <listitem>
                <para>The area where the actual data is plotted is called
                <firstterm>plot area</firstterm> and the class used to display
                the area is <classname>PlotArea2D</classname>, correspondingly.
                </para>
            </listitem>
            <listitem>
                <para>Depending on its type a plot can have an arbitrary number
                of axes which are created with the class <classname>Axis</classname>.
                Each <classname>Axis</classname> is displayed by an instance of
                <interfacename>AxisRenderer</interfacename>.</para>
            </listitem>
            <listitem>
                <para>Data points on the plot area are rendered by an instance of
                <interfacename>PointRenderer</interfacename>.</para>
            </listitem>
            <listitem>
                <para>Connections between data points are rendered by an instance
                of <interfacename>LineRenderer</interfacename></para>
            </listitem>
            <listitem>
                <para>In order to fill the area below data points an instance of
                <interfacename>AreaRenderer</interfacename> is used.</para>
            </listitem>
        </itemizedlist>
    </para>

    <sect1 xml:id="plotting.plots">
        <title>Plot types</title>

        <para>Currently, GRAL has three main plot types: xy-plot, bar plot, and
        pie plot. This section presents those plot types and show how to adjust
        their visual settings and to derive many more types. For example,
        xy-plots can be turned into line plots, or area plots and a pie chart
        can be made into a doughnut plot with just one command.</para>

        <sect2 xml:id="plotting.plots.xy">
            <title>XY-Plot</title>

            <para><classname>XYPlot</classname>:
            XY-Plots are usually the most common plot type. Used it whenever
            you want to create a line plot, a scatterplot, a bubble plot, or an
            area plot.</para>

            <example xml:id="example.plotting.plots.xy">
                <title>Creating an xy-plot</title>
                <programlisting language="java"><![CDATA[
Plot plot = new XYPlot(series1, series2);
]]></programlisting>
            </example>

            <sect3 xml:id="plotting.plots.xy.legend">
                <title>Legends</title>

                <para>Legends explain the symbols used
                in plot by the symbols and a description in a table-like
                representation. GRAL's <classname>Legend</classname> class
                can be either vertically (default) or horizontally oriented.
                Its options determine the positioning inside the plot as well
                as its background color, its border, or its spacings.</para>

                <example xml:id="example.plotting.plots.legend">
                    <title>Adding a legend to a plot</title>
                    <programlisting language="java"><![CDATA[
plot.setSetting(Plot.LEGEND, true);
]]></programlisting>
                </example>
            </sect3>
        </sect2>

        <sect2 xml:id="plotting.plots.bar">
            <title>Bar plot</title>

            <para>Usually, bar plots are used to show rectangular bars with
            lengths proportional to their corresponding values. GRAL provides a
            <classname>BarPlot</classname> class which is in fact a special
            case of an xy-plot.</para>

            <example xml:id="example.plotting.plots.bar">
                <title>Creating a bar plot</title>
                <programlisting language="java"><![CDATA[
Plot plot = new BarPlot(series);
]]></programlisting>
            </example>
        </sect2>

        <sect2 xml:id="plotting.plots.pie">
            <title>Pie plot</title>

            <para>Pie plots are circles divided into sectors to illustrate
            the proportions of the corresponding data values. GRAL's class
            <classname>PiePlot</classname> is used to create this type of plot.
            </para>

            <example xml:id="example.plotting.plots.pie">
                <title>Creating a pie plot</title>
                <programlisting language="java"><![CDATA[
Plot plot = new PiePlot(series);
]]></programlisting>
            </example>
        </sect2>
    </sect1>

    <sect1 xml:id="plotting.custom">
        <title>Custimization</title>

        <para>The visual properties of most classes in GRAL can be queried and
        changed using the methods
        <methodsynopsis language="java"><methodname>getSetting</methodname></methodsynopsis>
        and
        <methodsynopsis language="java"><methodname>setSetting</methodname></methodsynopsis>.
        This way, settings like colors, borders, margins, or positions can be
        easily customized.</para>

        <sect2 xml:id="plotting.custom.plot">
            <title>Customizing the plot</title>

            <para><classname>Plot</classname>s provide the canvas for painting
            all plot components (see <xref linkend="plotting"/>). It
            controls how the background will be drawn the way the components
            are positioned. Another important setting is the plot title.
            <xref linkend="example.plotting.custom.plot.title"/> shows how to
            set the title of an xy-plot.</para>

            <example xml:id="example.plotting.custom.plot.title">
                <title>Adding a title text</title>
                <programlisting language="java"><![CDATA[
Plot plot = new XYPlot(data);
plot.setSetting(XYPlot.TITLE, "My First XY Plot");
]]></programlisting>
            </example>

            <para>In <xref linkend="example.plotting.custom.plot.bg"/> you can
            see how a background gradient can be assigned to the whole plot.
            </para>

            <example xml:id="example.plotting.custom.plot.bg">
                <title>Adding a background gradient</title>
                <programlisting language="java"><![CDATA[
Plot plot = new PiePlot(data);
Paint gradient = new LinearGradientPaint(
    0f,0f,                 // Coordinates of gradient start point
    1f,0f,                 // Coordinates of gradient end point
    new float[] {0f, 1f},  // Relative fractions
    new Color[] {Color.GRAY, Color.WHITE}  // Gradient colors
);
plot.setSetting(Plot.BACKGROUND, gradient);
]]></programlisting>
            </example>

            <para>The <classname>PlotArea2D</classname> is the container for
            plotting the data. It must be fetched from a plot with the method,
            <methodsynopsis><methodname>getPlotArea</methodname></methodsynopsis>
            as each <classname>Plot</classname> type can also have its own plot
            area type. In <xref linkend="example.plotting.custom.plot.hide_plotarea"/>
            you can see how to hide the plot area itself completely.</para>

            <example xml:id="example.plotting.custom.plot.hide_plotarea">
                <title>Hiding the plot area</title>
                <programlisting language="java"><![CDATA[
PlotArea2D plotArea = plot.getPlotArea();
plotArea.setSetting(PlotArea2D.BACKGROUND, null);
plotArea.setSetting(PlotArea2D.BORDER, null);
]]></programlisting>
            </example>

            <para>Often, a legend has to added to a plot. Every plot already
            has a <classname>Legend</classname> which just has to be turned on
            explicitly. Then, the positioning, orientation, spacing, as well as
            the legend background can be changed.
            <xref linkend="example.plotting.custom.plot.legend"/> shows how to
            add a horizontal legend to the the bottom left corner of a plot.
            </para>

            <example xml:id="example.plotting.custom.plot.legend">
                <title>Adding a legend to a plot</title>
                <programlisting language="java"><![CDATA[
plot.setSetting(Plot.LEGEND, true);
plot.setSetting(Plot.LEGEND_LOCATION, Location.SOUTH_WEST);
Legend legend = plot.getLegend();
legend.setSetting(Legend.ORIENTATION, Orientation.HORIZONTAL);
]]></programlisting>
            </example>
        </sect2>

        <sect2 xml:id="plotting.custom.axis">
            <title>Customizing axes</title>

            <para>Axes of a plot have reasonable defaults for displaying.
            Sometimes however, it's necessary to add an axis title, adjust the
            spacing of the tick marks, or change the formatting of the data
            values along an axis. All those properties are controlled by the
            interface <interfacename>AxisRenderer</interfacename>. Each axis in
            a plot has its own instance and can have different settings.
            </para>

            <example xml:id="example.plotting.custom.axis.spacing">
                <title>Changing the spacing of tick marks</title>
                <programlisting language="java"><![CDATA[
AxisRenderer axisRendererX = plot.getAxisRenderer(XYPlot.AXIS_X);
axisRendererX.setSetting(AxisRenderer.TICKS_SPACING,  5.0);
]]></programlisting>
            </example>

            <para>There are to implementations of
            <interfacename>AxisRenderer</interfacename>: for axes with a linear
            scale (the default case) <classname>LinearRenderer2D</classname> is
            used; for axes with a logarithmic scale the class
            <classname>LogarithmicRenderer2D</classname> is used. For an example
            see <xref linkend="example.plotting.custom.axis.logarithmic"/>.
            </para>

            <example xml:id="example.plotting.custom.axis.logarithmic">
                <title>Adding a logarithmic axis</title>
                <programlisting language="java"><![CDATA[
XYPlot plot = new XYPlot(seriesLog, seriesLin);
AxisRenderer2D axisRendererX = new LogarithmicRenderer2D();
axisRendererX.setSetting(AxisRenderer.LABEL, "Logarithmic data");
plot.setAxisRenderer(XYPlot.AXIS_X, axisRendererX);
]]></programlisting>
            </example>

            <example xml:id="example.plotting.custom.axis.value_format">
                <title>Formatting axis values as dates</title>
                <programlisting language="java"><![CDATA[
AxisRenderer2D axisRendererX = new LogarithmicRenderer2D();
Format dateFormat = DateFormat.getTimeInstance();
axisRendererX.setSetting(AxisRenderer.TICK_LABELS_FORMAT, dateFormat);
]]></programlisting>
            </example>

            <example xml:id="example.plotting.custom.axis.custom_ticks">
                <title>Adding custom tick marks</title>
                <programlisting language="java"><![CDATA[
Map<Double, String> labels = new HashMap<Double, String>();
labels.put(2.0, "Doubled");
labels.put(1.5, "One and a half times");
axisRendererX.setSetting(AxisRenderer.TICKS_CUSTOM, labels);
]]></programlisting>
            </example>
        </sect2>

        <sect2 xml:id="plotting.custom.point">
            <title>Customizing points</title>

            <para>The display of data points in a plot is done by instances of
            <interfacename>PointRenderer</interfacename>. A point renderer
            defines the shape, the color, the size, and even the position of
            each point. A custom renderer can be implemented using either the
            interface <interfacename>PointRenderer</interfacename> itself or
            using the abstract class <classname>AbstractPointRenderer</classname>
            which is the preferred way.</para>

            <para>Every point renderer has to implement two methods:
            <methodsynopsis>
                <type>Drawable</type><methodname>getPoint</methodname>
                <methodparam><type>Axis</type><parameter>axis</parameter></methodparam>
                <methodparam><type>AxisRenderer</type><parameter>axisRenderer</parameter></methodparam>
                <methodparam><type>Row</type><parameter>row</parameter></methodparam>
            </methodsynopsis>
            returns a drawable component which then renders the points and
            <methodsynopsis>
                <type>Shape</type><methodname>getPointPath</methodname>
                <methodparam><type>Row</type><parameter>row</parameter></methodparam>
            </methodsynopsis>
            which returns the vector shape of a specified data point</para>

            <para>The class <classname>AbstractPointRenderer</classname>
            implements the interface <interfacename>PointRenderer</interfacename>
            and additionally it provides everything that's necessary to manage
            settings and draw basic elements.</para>

            <para>In <xref linkend="example.plotting.custom.point.simple"/> you
            can see how to implement a simple renderer.</para>

            <example xml:id="example.plotting.custom.point.simple">
                <title>A custom point renderer</title>
                <programlisting language="java"><![CDATA[
public class SimplePointRenderer extends DefaultPointRenderer {
    @Override
    public Drawable getPoint(final Axis axisY, final AxisRenderer axisYRenderer, final Row row) {
        Drawable drawable = new AbstractDrawable() {
            @Override
            public void draw(DrawingContext context) {
                Paint paint = SimplePointRenderer.this.getSetting(COLOR);
                Shape point = getPointPath(row);

                // Put your custom code here ...

                GraphicsUtils.fillPaintedShape(context.getGraphics(), point, paint, null);
            }
        };
        return drawable;
    }

    @Override
    public Shape getPointPath(Row row) {
        Shape shape = getSetting(SHAPE);
        return shape;
    }
}
]]></programlisting>
            </example>
        </sect2>

        <sect2 xml:id="plotting.custom.line">
            <title>Customizing lines</title>

            <para>Data points can be connected using lines. To draw these lines
            instances of <interfacename>LineRenderer</interfacename> are used.
            A line renderer has full control over the line shapes, the stroke
            patterns, and the colors which will be used when drawing. Custom
            renderers can be easily implemented using either the interface
            <interfacename>LineRenderer</interfacename> itself or using the
            abstract class <classname>AbstractLineRenderer2D</classname> which
            is the preferred way for two-dimensional applications.</para>

            <para>Every line renderer has to implement one method:
            <methodsynopsis>
                <type>Drawable</type><methodname>getLine</methodname>
                <methodparam><type>Iterable&lt;DataPoint&gt;</type><parameter>points</parameter></methodparam>
            </methodsynopsis>
            returns a drawable component to display the lines.</para>

            <para>The class <classname>AbstractLineRenderer2D</classname>
            implements the interface <interfacename>LineRenderer</interfacename>
            for two-dimensional data and additionally provides everything that's
            necessary to manage settings and draw basic elements.</para>

            <para>In <xref linkend="example.plotting.custom.line.simple"/> you
            can see how to implement a simple renderer.</para>

            <example xml:id="example.plotting.custom.line.simple">
                <title>A custom line renderer</title>
                <programlisting language="java"><![CDATA[
public class SimpleLineRenderer2D extends AbstractLineRenderer2D {
    @Override
    public Drawable getLine(final Iterable<DataPoint> points) {
        Drawable d = new AbstractDrawable() {
            @Override
            public void draw(DrawingContext context) {
                Path2D line = new Path2D.Double();
                for (DataPoint point : points) {
                    Point2D pos = point.getPosition().getPoint2D();
                    if (line.getCurrentPoint() == null) {
                        line.moveTo(pos.getX(), pos.getY());
                    } else {
                        line.lineTo(pos.getX(), pos.getY());
                    }
                }
                Shape lineShape = punch(line, points);
                Paint paint = SimpleLineRenderer2D.this.getSetting(LineRenderer.COLOR);
                GraphicsUtils.fillPaintedShape(context.getGraphics(), lineShape, paint, null);
            }
        };
        return d;
    }
}
]]></programlisting>
            </example>
        </sect2>

        <sect2 xml:id="plotting.custom.area">
            <title>Customizing areas</title>

            <para>In order to display filled or hatched areas in plots so called
            area renderers are used. They all derive from the interface
            <interfacename>AreaRenderer</interfacename> and they control the
            colors, the fillings, and also the shape of the rendered area.
            Custom renderers can be easily implemented using either the
            interface <interfacename>AreaRenderer</interfacename> itself or
            using the abstract class <classname>AbstractAreaRenderer</classname>
            which is the preferred way.</para>

            <para>Every area renderer has to implement one method:
            <methodsynopsis>
                <type>Drawable</type><methodname>getArea</methodname>
                <methodparam><type>Axis</type><parameter>axis</parameter></methodparam>
                <methodparam><type>AxisRenderer</type><parameter>axisRenderer</parameter></methodparam>
                <methodparam><type>Iterable&lt;DataPoint&gt;</type><parameter>points</parameter></methodparam>
            </methodsynopsis>
            returns a drawable component to display the area.</para>

            <para>The class <classname>AbstractAreaRenderer</classname>
            implements the interface <interfacename>AreaRenderer</interfacename>
            and additionally it provides everything that's necessary to manage
            settings and draw basic elements.</para>

            <para>In <xref linkend="example.plotting.custom.area.simple"/> you
            can see how to implement a simple renderer.</para>

            <example xml:id="example.plotting.custom.area.simple">
                <title>A custom area renderer</title>
                <programlisting language="java"><![CDATA[
public class SimpleAreaRenderer extends AbstractAreaRenderer {
    @Override
    public Drawable getArea(Axis axis, AxisRenderer axisRenderer,
            Iterable<DataPoint> points) {
        Shape path = getAreaShape(axis, axisRenderer, points);
        final Shape area = punch(path, points);

        return new AbstractDrawable() {
            @Override
            public void draw(DrawingContext context) {
                Paint paint = SimpleAreaRenderer.this.getSetting(COLOR);
                GraphicsUtils.fillPaintedShape(context.getGraphics(),
                        area, paint, area.getBounds2D());
            }
        };
    }

    private Shape getAreaShape(Axis axis, AxisRenderer axisRenderer,
            Iterable<DataPoint> points) {
        // Code to construct the shape
        ...
    }
}
]]></programlisting>
            </example>
        </sect2>

        <sect2 xml:id="plotting.export">
            <title>Exporting plot images</title>

            <para>Usage similar to data import/export. Bitmap formats like
            <acronym>PNG</acronym>, <acronym>JPEG</acronym>, <acronym>BMP</acronym>,
            or <acronym>GIF</acronym> and vector formats like
            <acronym>SVG</acronym>, <acronym>PDF</acronym>, <acronym>EPS</acronym>.
            </para>

            <example xml:id="example.plotting.export">
                <title>Exporting an <acronym>SVG</acronym> image</title>
                <programlisting language="java"><![CDATA[
XYPlot plot = new XYPlot(data);
DrawableWriter writer = DrawableWriterFactory.getInstance().get("image/svg+xml");
FileOutputStream file = new FileOutputStream("xyplot.svg");
double width = 320.0, height = 240.0;
writer.write(plot, file, width, height);
]]></programlisting>
            </example>
        </sect2>
    </sect1>
</chapter>

<chapter xml:id="extension">
    <title>Extending GRAL</title>

    <para>GRAL can be extended in numerous ways to better suit your needs.
    For example, you can write your own plot types, line types, axes, or data
    exchange plug-ins. The following chapter shows you how to use GRAL's
    application programming interface to tailor it for your requirements.</para>

    <sect1 xml:id="extension.plot">
        <title>Writing a new plot type</title>

        <para><classname>Plot</classname> class,
        <interfacename>DataListener</interfacename> interface.</para>

        <example xml:id="example.plotting.export">
            <title>Creating a custom <classname>Plot</classname></title>
            <programlisting language="java"><![CDATA[
public class MyPlot extends Plot implements DataListener {
    public static final Key MY_SETTING = new Key("myplot.mysetting");

    public MyPlot(DataSource data) {
        super(data);
        setSettingDefault(MY_SETTING, 1.0);
        ...
        dataChanged(data);
        data.addDataListener(this);
    }

    @Override
    public void dataChanged(DataSource data) {
        ...
    }
}
]]></programlisting>
        </example>
    </sect1>

    <sect1 xml:id="extension.import.data">
        <title>Writing a data importer</title>

        <para><classname>DataReaderFactory</classname> and <interfacename>DataReader</interfacename>.</para>

        <example xml:id="example.plotting.import">
            <title>Creating a custom <classname>DataReader</classname></title>
            <programlisting language="java"><![CDATA[
public class MyReader extends IOCapabilitiesStorage implements DataReader {
    static {
        addCapabilities(new IOCapabilities(
            "My Format",
            "My custom file format",
            "application/x-myformat",
            "myf"
        ));
    }

    private final Map<String, Object> settings;
    private final Map<String, Object> defaults;
    private final String mimeType;

    public MyReader(String mimeType) {
        this.mimeType = mimeType;
        settings = new HashMap<String, Object>();
        defaults = new HashMap<String, Object>();
        defaults.put("my setting", "foobar");
    }

    @Override
    public DataSource read(InputStream input, Class<? extends Number>... types) throws IOException, ParseException;
        ...
    }

    /**
     * Returns the MIME type.
     * @return MIME type string.
     */
    public String getMimeType() {
        return mimeType;
    }

    @Override
    public <T> T getSetting(String key) {
        if (!settings.containsKey(key)) {
            return (T) defaults.get(key);
        }
        return (T) settings.get(key);
    }

    @Override
    public <T> void setSetting(String key, T value) {
        settings.put(key, value);
    }
}
]]></programlisting>
        </example>
    </sect1>

    <sect1 xml:id="extension.export.data">
        <title>Writing a data exporter</title>

        <para><classname>DataWriterFactory</classname> and <interfacename>DataWriter</interfacename>.</para>

        <example xml:id="example.plotting.export">
            <title>Creating a custom <classname>DataWriter</classname></title>
            <programlisting language="java"><![CDATA[
public class MyWriter extends IOCapabilitiesStorage implements DataWriter {
    static {
        addCapabilities(new IOCapabilities(
            "My Format",
            "My custom file format",
            "application/x-myformat",
            "myf"
        ));
    }

    private final Map<String, Object> settings;
    private final Map<String, Object> defaults;
    private final String mimeType;

    public MyWriter(String mimeType) {
        this.mimeType = mimeType;
        settings = new HashMap<String, Object>();
        defaults = new HashMap<String, Object>();
        defaults.put("my setting", "foobar");
    }

    @Override
    public void write(DataSource data, OutputStream output) throws IOException {
        ...
    }

    /**
     * Returns the MIME type.
     * @return MIME type string.
     */
    public String getMimeType() {
        return mimeType;
    }

    @Override
    public <T> T getSetting(String key) {
        if (!settings.containsKey(key)) {
            return (T) defaults.get(key);
        }
        return (T) settings.get(key);
    }

    @Override
    public <T> void setSetting(String key, T value) {
        settings.put(key, value);
    }
}
]]></programlisting>
        </example>
    </sect1>

    <sect1 xml:id="extension.export.plot">
        <title>Writing a plot exporter</title>

        <para><classname>DrawableWriterFactory</classname> and <interfacename>DrawableWriter</interfacename>.
        Either <classname>BitmapWriter</classname> or <classname>VectorWriter</classname>.</para>
    </sect1>
</chapter>

<chapter xml:id="limitations">
   <title>Limitations</title>

    <para>Due to its early stage of development, GRAL still has several
    limitations:

        <itemizedlist>
            <listitem><para>It is not very fast for larger data sets</para></listitem>
            <listitem><para>Despite we try our best to ensure code quality it still has some bugs</para></listitem>
        </itemizedlist>
    </para>
</chapter>

</book>
